program Tetris;

uses crt, SysUtils, GetKeyU;

const
    FIELD_WIDTH = 20;
    FIELD_HEIGHT = 30;
    FIELD_OFFSET_Y = 2;
    FIELD_OFFSET_X = 5;
    FIGURE_COUNT = 7;
    FIGURE_WIDTH = 8;
    FIGURE_HEIGHT = 8;
    FILENAME_FOR_SCORE = 'data_score_ladder';

    FIGURES: array [
        1..FIGURE_COUNT, 1..FIGURE_HEIGHT, 1..FIGURE_WIDTH
    ] of integer = (
        { I/ftype = 1 }
        (
            { row 1/2 }
            (0, 0, 0, 0, 0, 0, 0, 0), (1, 1, 1, 1, 1, 1, 1, 1),
            { row 3/4 }
            (1, 1, 1, 1, 1, 1, 1, 1), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 5/6 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 7/8 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)
        ),
        { O/ftype = 2 }
        (
            { row 1/2 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 1, 1, 1, 1, 0, 0),
            { row 3/4 }
            (0, 0, 1, 1, 1, 1, 0, 0), (0, 0, 1, 1, 1, 1, 0, 0),
            { row 5/6 }
            (0, 0, 1, 1, 1, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 7/8 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)
        ),
        { T/ftype = 3 }
        (
            { row 1/2 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 1, 1, 0, 0, 0, 0),
            { row 3/4 }
            (0, 0, 1, 1, 0, 0, 0, 0), (1, 1, 1, 1, 1, 1, 0, 0),
            { row 5/6 }
            (1, 1, 1, 1, 1, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 7/8 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)
        ),
        { S/ftype = 4 }
        (
            { row 1/2 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 1, 1, 1, 1, 0, 0),
            { row 3/4 }
            (0, 0, 1, 1, 1, 1, 0, 0), (1, 1, 1, 1, 0, 0, 0, 0),
            { row 5/6 }
            (1, 1, 1, 1, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 7/8 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)
        ),
        { Z/ftype = 5 }
        (
            { row 1/2 }
            (0, 0, 0, 0, 0, 0, 0, 0), (1, 1, 1, 1, 0, 0, 0, 0),
            { row 3/4 }
            (1, 1, 1, 1, 0, 0, 0, 0), (0, 0, 1, 1, 1, 1, 0, 0),
            { row 5/6 }
            (0, 0, 1, 1, 1, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 7/8 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)
        ),
        { J/ftype = 6 }
        (
            { row 1/2 }
            (0, 0, 0, 0, 0, 0, 0, 0), (1, 1, 0, 0, 0, 0, 0, 0),
            { row 3/4 }
            (1, 1, 0, 0, 0, 0, 0, 0), (1, 1, 1, 1, 1, 1, 0, 0),
            { row 5/6 }
            (1, 1, 1, 1, 1, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 7/8 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)
        ),
        { L/ftype = 7 }
        (
            { row 1/2 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 1, 1, 0, 0),
            { row 3/4 }
            (0, 0, 0, 0, 1, 1, 0, 0), (1, 1, 1, 1, 1, 1, 0, 0),
            { row 5/6 }
            (1, 1, 1, 1, 1, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
            { row 7/8 }
            (0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)
        )
    );

type
    TField = array[1..FIELD_HEIGHT, 1..FIELD_WIDTH] of integer;
    TFigure = array[1..FIGURE_HEIGHT, 1..FIGURE_WIDTH] of integer;
    TFile = file of integer;

    TQueuePointer = ^TQueue;
    TQueue = record
        data: integer;
        next: TQueuePointer;
    end;

    TQueueRecord = record
        first, last: TQueuePointer;
    end;

{ #global var}
var
    field: TField;
    currentFig: TFigure;
    figX, figY, figType: integer;
    score, level: integer;
    gameOver: boolean;

procedure DrawInfo;
begin
    TextColor(Yellow);
    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y);
    write('TETRIS');

    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 2);
    write('Score: ');
    TextColor(Red);
    write(score);
    TextColor(Yellow);

    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 3);
    write('Level: ');
    TextColor(Red);
    write(level);
    TextColor(Yellow);

    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 5);
    write('Keys:');
    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 6);
    write('LeftArrow/RightArrow - Left/Right');
    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 7);
    write('UpArrow - Rotate');
    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 8);
    write('DownArrow - FastMove');
    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 9);
    write('Space - Pause game');
    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 10);
    write('ESC - Close game');
end;

procedure InitField;
var
    i, j: integer;
begin
    for i := 1 to FIELD_HEIGHT do
    begin
        for j := 1 to FIELD_WIDTH do
        begin
            field[i, j] := 0;
        end
    end
end;

procedure DrawBorder;
var
    i: integer;
begin
    for i := 1 to FIELD_HEIGHT do
    begin
        GotoXY(FIELD_OFFSET_X - 1, FIELD_OFFSET_Y + i - 1);
        write('|');
        GotoXY(FIELD_OFFSET_X + FIELD_WIDTH, FIELD_OFFSET_Y + i - 1);
        write('|');
    end;

    GotoXY(FIELD_OFFSET_X - 1, FIELD_OFFSET_Y + FIELD_HEIGHT);
    for i := 1 to FIELD_WIDTH + 2 do
        write('-')
end;

procedure LoadFigure(figNum: integer);
var
    i, j: integer;
begin
    for i := 1 to FIGURE_HEIGHT do
    begin
        for j := 1 to FIGURE_WIDTH do
        begin
            currentFig[i, j] := FIGURES[figNum, i, j]
        end
    end
end;

procedure DrawField;
var
    i, j: integer;
begin
    for i := 1 to FIELD_HEIGHT do
    begin
        for j := 1 to FIELD_WIDTH do
        begin
            GotoXY(FIELD_OFFSET_X + j - 1, FIELD_OFFSET_Y + i - 1);
            if field[i, j] > 0 then
            begin
                TextColor(field[i, j]);
                write('#')
            end
            else
                write(' ')
        end
    end
end;

procedure RotateFigure;
var
    tmpFig: TFigure;
    i, j: integer;
begin
    { Don't rotate O figure }
    if figType = 2 then
        exit;

    for i := 1 to FIGURE_HEIGHT do
    begin
        for j := 1 to FIGURE_WIDTH do
        begin
            tmpFig[i, j] := currentFig[FIGURE_HEIGHT - j + 1, i]
        end
    end;
    currentFig := tmpFig
end;

function CanPlace(x, y: integer): boolean;
var
    i, j, fieldY, fieldX: integer;
begin
    CanPlace := true;

    for i := 1 to FIGURE_HEIGHT do
    begin
        for j := 1 to FIGURE_WIDTH do
        begin
            if currentFig[i, j] > 0 then
            begin
                fieldY := y + i - 1;
                fieldX := x + j - 1;

                if (fieldX < 1) or (fieldX > FIELD_WIDTH) or 
                   (fieldY < 1) or (fieldY > FIELD_HEIGHT) then
                begin
                    CanPlace := false;
                    exit
                end;

                if field[fieldY, fieldX] > 0 then
                begin
                    CanPlace := false;
                    exit
                end
            end
        end
    end
end;

procedure PlaceFigure;
var
    i, j: integer;
begin
    for i := 1 to FIGURE_HEIGHT do
    begin
        for j := 1 to FIGURE_WIDTH do
        begin
            if currentFig[i, j] > 0 then
                field[figY + i - 1, figX + j - 1] := figType
        end
    end
end;

procedure DrawCurrentFigure;
var
    i, j: integer;
begin
    TextColor(figType);
    for i := 1 to FIGURE_HEIGHT do
    begin
        for j := 1 to FIGURE_WIDTH do
        begin
            if currentFig[i, j] > 0 then
            begin
                GotoXY(
                    FIELD_OFFSET_X + figX + j - 2,
                    FIELD_OFFSET_Y + figY + i - 2
                );
                write('#')
            end
        end
    end;
end;

procedure CheckLines;
var
    i, j, k: integer;
    full: boolean;
    linesCleared: integer;
begin
    linesCleared := 0;
    i := FIELD_HEIGHT;

    while i >= 1 do
    begin
        full := true;
        for j := 1 to FIELD_WIDTH do
        begin
            if field[i, j] = 0 then
            begin
                full := false;
                break
            end
        end;
    
        if full then
        begin
            linesCleared := linesCleared + 1;
            for k := i downto FIGURE_HEIGHT div 2 do
            begin
                for j := 1 to FIELD_WIDTH do
                begin
                    field[k, j] := field[k - 1, j]
                end;
                for j := 1 to FIELD_WIDTH do
                begin
                    field[1, j] := 0
                end
            end
        end
        else
            i := i - 1
    end;

    if linesCleared > 0 then
    begin
        score := score + linesCleared * 100 * level;
        if score div 1000 > level - 1 then
            level := level + 1;
    end
end;

procedure NewFigure;
begin
    figType := random(FIGURE_COUNT) + 1;
    LoadFigure(figType);
    figX := FIELD_WIDTH div 2 - 1;
    figY := 1;

    if not CanPlace(figX, figY) then
        gameOver := true
end;

procedure PauseGame(saveTextAttr: integer);
begin
    GotoXY(1, 1);
    TextColor(Red);
    write('Game paused, type Enter for continue play');
    GotoXY(1, 1);
    readln;
    clrscr;
    TextAttr := saveTextAttr;
    DrawBorder
end;

procedure QInit(var q: TQueueRecord);
begin
    q.first := nil;
    q.last := nil
end;

procedure QPut(var q: TQueueRecord; n: integer);
begin
    if q.first = nil then
    begin
        new(q.first);
        q.last := q.first
    end
    else
    begin
        new(q.last^.next);
        q.last := q.last^.next
    end;
    q.last^.data := n;
    q.last^.next := nil
end;

procedure test(var f: TFile; saveTextAttr: integer);
var
    n, i, tmpNum: integer;
    q, q2: TQueueRecord;
    pp, pp2: ^TQueuePointer;
    q2HaveThisNum: boolean;
begin
    {$I-}
    { open file }
    assign(f, FILENAME_FOR_SCORE);
    reset(f);
    if IOResult <> 0 then
    begin
        rewrite(f);
    end;

    { read file and upload data to queue }
    if score > 0 then
    begin
        QInit(q);
        while not eof(f) do
        begin
            read(f, n);
            QPut(q, n);
        end;
        close(f);
        QPut(q, score)
    end;

    { craete new queue }
    tmpNum := 0;
    QInit(q2);
    QPut(q2, tmpNum);
    pp := @(q.first);
    pp2 := @(q2.first);
    while pp^ <> nil do
    begin
        tmpNum := pp^^.data;

        { check/add unic number } 
        while pp2^ <> nil do
        begin
            if tmpNum = pp2^^.data then
            begin
                q2HaveThisNum := true;
                break
            end
            else
            begin
                q2HaveThisNum  := false;
                pp2 := @(pp2^^.next)
            end
        end;
        if not q2HaveThisNum then
            QPut(q2, tmpNum);
        pp2 := @(q2.first);

        pp := @(pp^^.next)
    end;

    { sort numbers }
    pp := @(q2.first);
    i := 0;
    while pp^ <> nil do
    begin
        tmpNum := pp^^.data;
        if (pp^^.next <> nil) and (pp^^.data > pp^^.next^.data) then
        begin
            tmpNum := pp^^.next^.data;
            pp^^.next^.data := pp^^.data;
            pp^^.data := tmpNum;

        end;

        GotoXY(10, 30 + i);
        writeln(tmpNum);
        readln;

        i := i + 1;
        pp := @(pp^^.next)
    end;

    { write ladder for display }
    i := 6;
    TextColor(Blue);
    GotoXY(1, 5);
    write('TOP 10 score: ');
    pp := @(q2.first);
    while pp^ <> nil do
    begin
        if pp^^.data < 1 then
            pp := @(pp^^.next);

        GotoXY(1, i);
        TextColor(Red);
        write(i-5, ': ');
        TextColor(Yellow);
        write(pp^^.data);
        i := i + 1;
        pp := @(pp^^.next)
    end;

    { write data file }
    rewrite(f);
    pp := @(q2.first);
    while pp^ <> nil do
    begin
        if pp^^.data < 1 then
            pp := @(pp^^.next);

        write(f, pp^^.data);
        pp := @(pp^^.next)
    end;
    close(f);

    TextAttr := saveTextAttr
end;

var
    lastMove: QWord;
    moveDelay: integer;
    keyCode: integer;
    scoreFile: TFile;
    saveTextAttr: integer;
begin
    randomize;
    clrscr;
    CursorOff;
    saveTextAttr := TextAttr;

    InitField;
    score := 0;
    level := 1;
    gameOver := false;

    DrawBorder;
    NewFigure;
    lastMove := GetTickCount64;

    while not gameOver do
    begin
        moveDelay := 500 - (level - 1) * 50;
        if moveDelay < 100 then
            moveDelay := 100;

        if KeyPressed then
        begin
            GetKey(keyCode);
            case keyCode of
                -75: { left }
                begin
                    if CanPlace(figX - 1, figY) then
                        figX := figX - 1;
                end;
                -77: { right }
                begin
                    if CanPlace(figX + 1, figY) then
                        figX := figX + 1;
                end;
                -72: { up }
                begin
                    RotateFigure;
                    if not CanPlace(figX, figY)then
                    begin
                        RotateFigure;
                        RotateFigure;
                        RotateFigure
                    end
                end;
                -80: { down }
                begin
                    moveDelay := 50
                end;
                32: { space }
                begin
                    PauseGame(saveTextAttr)
                end;
                27: { esc }
                begin
                    gameOver := true;
                    TextAttr := SaveTextAttr;
                    clrscr;
                    halt(1)
                end
            end;
        end;

        if (GetTickCount64 - lastMove > moveDelay) then
        begin
            if CanPlace(figX, figY + 1) then
            begin
                figY := figY + 1;
            end
            else
            begin
                delay(50);
                if CanPlace(figX, figY + 1) then
                    continue;
                    
                PlaceFigure;
                CheckLines;
                NewFigure;
            end;
            lastMove := GetTickCount64
        end;

        DrawField;
        DrawCurrentFigure;
        DrawInfo;

        delay(30)
    end;

    { Post game info }
    clrscr;
    GotoXY(1, 1);
    TextColor(Red);
    write('Score: ', score);
    GotoXY(FIELD_OFFSET_X + FIELD_WIDTH + 5, FIELD_OFFSET_Y + 3);
    TextAttr := SaveTextAttr;
    GotoXY(1, 3);
    Write('Please type Enter for close game');

    { save score }
    score := 100;
    test(scoreFile, saveTextAttr);

    readln;
    CursorOn;
    clrscr
end.
